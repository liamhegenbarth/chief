
const _ 			= require('./helpers'),
	  pug 			= require('pug');


class Chief {


	constructor( params )
	{

		const settings = params || {};

		// Merge of default and user defined settings
		this.settings 	= _.extend( {}, this.defaultSettings(), settings );

		this.express 	= require('express');
		this.app    	= this.express();
		this.server 	= require('http').Server(this.app);
		this.bodyParser = require('body-parser');

		this.map = {};

// console.log(this.settings);

		this.init();

		return;

	}


	defaultSettings()
	{

		return {
			middleware 	: false,
			engine 		: 'jade',
			public 		: './public',
			views 		: './views',
			content 	: './content',
			compiled 	: './compiled',
			error 		: 'errors/error',
			index 		: 'index',
			divider 	: '+++',
			port 		: 8080
		}

	}


	init()
	{
		this.getData();
	}


	getData()
	{

		// loop through content files
		// and generate a fuck off big Object :)
		const files = _.glob(`${this.settings.content}/**/*.*(md|toml)`);

		for ( let file = 0; file < files.length; file++ )
		{

			let dirs = files[file].replace(`${this.settings.content}/`, '').split('/');

			this.recurseFiles( files[file], this.map, dirs, 0 );

		}

		// now build server
		this.buildServer();

		this.compile();

	}


	recurseFiles( file, object, dirs, depth )
	{
		
		// create new key for config file
		if ( _.index(dirs[0], '.toml') )
		{
			object[ dirs[0].split('.toml')[0] ] = _.read.data(_.read.file(file));
		}
		// create new key for page
		else if ( _.index(dirs[0], '.md') )
		{

			var filename 	= dirs[0].split('.md')[0],
				data 		= _.read.file(file).split(`${this.settings.divider}`),
				path 		= file.replace(this.settings.content, '').split(dirs[0])[0],
				document 	= _.read.data(data[1]);

			document.markdown = _.read.content(data[2]);

			if ( !document.hasOwnProperty('title') )
			{
				document.title = _.capitalise(filename);
			}

			if ( !document.hasOwnProperty('slug') )
			{
				document.slug = filename;
			}

			if ( !document.hasOwnProperty('path') )
			{
				document.path = `/${path}`;
			}

			if ( !document.hasOwnProperty('href') )
			{
				document.href = `/${path}${filename}`;
			}

			if ( !document.hasOwnProperty('depth') )
			{
				document.depth = ++depth;
			}


			if ( depth > 0 )
			{

				if ( _.index(dirs[0], `${this.settings.index}.md`) )
				{
					object[filename] = document;
				}
				else
				{
					if ( !object.hasOwnProperty('pages') )
					{
						object.pages = {};
					}
					
					object.pages[filename] = document;
				}

			}
		}
		// create new key for directory
		else
		{
			if ( !object.hasOwnProperty('pages') )
			{
				object.pages = {};
			}

			// test if object has key
			if ( object.pages.hasOwnProperty( dirs[0] ) )
			{
				var newObject = object.pages[ dirs[0] ];
			}
			else
			{
				var newObject = object.pages[ dirs[0] ] = {};
			}
			
			dirs.shift();

			this.recurseFiles( file, newObject, dirs, ++depth );
		}

	}


	buildServer()
	{

		this.app.use(this.bodyParser.urlencoded({ extended : true }));
		this.app.use(this.bodyParser.json());

		this.app.set('views', this.settings.views);  
		this.app.set('view engine', this.settings.engine);

		this.app.use(this.express.static(`${__dirname}/${this.settings.public}`));

		this.server.listen(this.settings.port);


		// now expose middleware _.ready for requests
		this.setMiddleware();

	}


	setMiddleware()
	{

		if ( this.settings.middleware )
		{

			for ( let m; m < this.settings.middleware.length; m++ )
			{

				this.app.use((req, res, next) => {

					this.settings.middleware[m].call(req, res);

					next();

				});

			}

		}

		// now expose routes _.ready for requests
		this.setRoutes();

	}


	setRoutes()
	{

		this.app.get('*', (req, res) => {

			if ( PROCESS.ENV.isProduction() )
			{
				this.getRouteProd(req, res);
			}
			else
			{
				this.getRouteDev(req, res);
			}


			// try loading the page
			_.read.file(`${this.settings.content}${req.url}.md`, (err, file) => {

				// if it fails, we assume its a section, so look for the _.index page
				( err )

					// try loading the _.index page
					? _.read.file(`${this.settings.content}/${req.url}/${this.settings.index}.md`, (err, file) => {

						// if it fails, the page doesn't exist at all, 404
						( err )
							
							? this.render(err, req, res, file)
						
							// _.index page does exist, so render template
							: this.render(err, req, res, file);

					})

					// normal page does exist, so render template
					: this.render(err, req, res, file);

			});

		});

		return;

	}


	getRouteProd( req, res )
	{

	}


	getRouteDev( req, res )
	{
		
	}


	renderDev()
	{

	}

	renderProd()
	{

	}


	render( err, req, res, file )
	{

		if ( err )
		{
			res.render(this.settings.error, 
			{
				Chief : this.map
			});
		}
		else
		{
			const local 	= _.setLocal(file, this.settings),
				  template 	= _.setTemplate(req.url, local, this.map.pages, this.settings);
				  
			res.render(template, 
			{
				Chief : {
					global 	: this.map.global,
					pages 	: this.map.pages,
					local 	: local
				}
			});
		}

		return;

	}


	compile()
	{

		// !!! The process !!! //

		// glob content and glob compiled
		// use returned files to create arrays of files and directories
		// reduce arrays down to unique directory paths and files
		// then we trigger our erase and write cycle based on a diff of the arrays

		// 1. write directories
		// 2. write files
		// 3. erase files
		// 4. erase directories


		// !!! lets go !!! //

		// glob content and compile files
		const content 	= _.glob(`${this.settings.content}/**/*.md`),
			  compiled 	= _.glob(`${this.settings.compiled}/**/*.html`),

		// reduce files array down to unique directory paths
			  contentDirs = _.reduceDirectories(content),
			  compileDirs = _.reduceDirectories(compiled),

		// diff the arrays to find new or old directories and files
			  contentDirsDiff = _.diffDirectories(contentDirs, compileDirs),
			  compileDirsDiff = _.diffDirectories(compileDirs, contentDirs),

		// update the paths to resolve to the compiled directory
			  contentDirsPaths = _.updateDirectories(contentDirsDiff, this.settings.compiled),
			  compileDirsPaths = _.updateDirectories(compileDirsDiff, this.settings.compiled),

	    // reduce files array down to unique directory paths
			  contentFiles = _.reduceFiles(content),
			  compileFiles = _.reduceFiles(compiled),

		// diff the arrays to find new or old directories and files
			  contentFilesDiff = _.diffFiles(contentFiles, compileFiles),
			  compileFilesDiff = _.diffFiles(compileFiles, contentFiles),

		// update the paths to resolve to the content directory
			  contentFilesPaths = contentFilesDiff,
			  compileFilesPaths = _.updateFiles(compileFilesDiff, this.settings.compiled, 'html');
		

		const matrix = {

            content : {
                files : contentFilesPaths,
                dirs : contentDirsPaths
            },
            compile : {
                files : compileFilesPaths,
                dirs : compileDirsPaths
            }

        };


        // !!! begin the write and erase cycle !!! //
        this.writeDirectories(matrix);

    }


	writeDirectories( matrix )
    {

        const dirs = matrix.content.dirs;

        if ( dirs )
        {
            // use sync _.write as shallow dirs need to be made before deepest dirs
            for ( let dir = 0; dir < dirs.length; dir++ )
            {
                try
                {
                	_.write.dir(dirs[dir]);
                }
                catch(err)
                {
                	_.error(err, this.settings);
                }
            }
        }

        this.writeFiles(matrix);

    }


	writeFiles( matrix )
	{

		const files = matrix.content.files;

		if ( files )
		{

			const content = _.updateFiles(files, this.settings.content, 'md'),
				  compile = _.updateFiles(files, this.settings.compiled, 'html');

			for ( let f = 0; f < files.length; f++ )
			{

				const path = content[f];

				_.read.file(path, (err, file) => {

					let url 		= files[f].replace('{root}', '').replace('{ext}', ''),

						local 		= _.setLocal(file, this.settings),
						template 	= _.setTemplate(url, local, this.map.pages, this.settings),
						extension 	= ( _.index(template, '.jade') ) ? '' : '.jade',

						render 		= `${this.settings.views}/${template}${extension}`,

						chief 		= {
							Chief : {
								global 	: this.map.global,
								pages 	: this.map.pages,
								local 	: local
							}
						},
						
						html 		= pug.renderFile(render, chief);


					try
					{
						_.write.file(compile[f], html);
					}
					catch(err)
	                {
	                	_.error(err, this.settings);
	                }

				});

			}

		}

		this.eraseFiles(matrix);

	}


	eraseFiles( matrix )
    {

        const files = matrix.compile.files;

        if ( files )
        {
            // use sync _.erase as deepest files need to be made before shallowest files
            for ( let f = files.length; f > 0; f-- )
            {
                try 
                {
                	_.erase.file(files[f-1]);
                }
                catch(err)
                {
                	_.error(err, this.settings);
                }
            }
        }

        this.eraseDirectories(matrix);

    }


    eraseDirectories( matrix )
    {

        const dirs = matrix.compile.dirs;

        if ( dirs )
        {
            // use sync _.erase as deepest files need to be made before shallowest files
            for ( let d = dirs.length; d > 0; d-- )
            {
                try
                {
                	_.erase.dir(dirs[d-1]);
                }
                catch(err)
                {
                	_.error(err, this.settings);
                }
            }
        }

        this.end();

    }


    end()
    {
    	_.message(`Chief running with wolves on port ${this.settings.port}`);
    }


}


module.exports = Chief;


