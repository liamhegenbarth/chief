
const _ 			= require('./helpers'),
	  pug 			= require('pug');


class Chief {


	constructor( params )
	{

		const settings = params || {};

		// Merge of default and user defined settings
		this.settings 	= _.extend( {}, this.defaultSettings(), settings );

		this.express 	= require('express');
		this.app    	= this.express();
		this.server 	= require('http').Server(this.app);
		this.bodyParser = require('body-parser');

		this.map = {};

console.log(this.settings);

		this.init();

		return;

	}


	defaultSettings()
	{

		return {
			middleware 	: false,
			engine 		: 'jade',
			public 		: './public',
			views 		: './views',
			content 	: './content',
			compiled 	: './compiled',
			error 		: 'errors/error',
			index 		: 'index',
			divider 	: '+++',
			port 		: 8080
		}

	}


	init()
	{
		this.getData();
	}


	getData()
	{

		// loop through content files
		// and generate a fuck off big Object :)
		const files = _.glob(`${this.settings.content}/**/*.*(md|toml)`);

		for ( let file = 0; file < files.length; file++ )
		{

			let dirs = files[file].replace(`${this.settings.content}/`, '').split('/');

			this.recurseFiles( files[file], this.map, dirs, 0 );

		}

		// now build server
		this.buildServer();

		this.compile();

	}


	recurseFiles( file, object, dirs, depth )
	{
		
		// create new key for config file
		if ( _.index(dirs[0], '.toml') )
		{
			object[ dirs[0].split('.toml')[0] ] = _.read.data(_.read.file(file));
		}
		// create new key for page
		else if ( _.index(dirs[0], '.md') )
		{

			var filename 	= dirs[0].split('.md')[0],
				data 		= _.read.file(file).split(`${this.settings.divider}`),
				path 		= file.replace(this.settings.content, '').split(dirs[0])[0],
				document 	= _.read.data(data[1]);

			document.markdown = _.read.content(data[2]);

			if ( !document.hasOwnProperty('title') )
			{
				document.title = _.capitalise(filename);
			}

			if ( !document.hasOwnProperty('slug') )
			{
				document.slug = filename;
			}

			if ( !document.hasOwnProperty('path') )
			{
				document.path = `/${path}`;
			}

			if ( !document.hasOwnProperty('href') )
			{
				document.href = `/${path}${filename}`;
			}

			if ( !document.hasOwnProperty('depth') )
			{
				document.depth = ++depth;
			}


			if ( depth > 0 )
			{

				if ( _.index(dirs[0], `${this.settings.index}.md`) )
				{
					object[filename] = document;
				}
				else
				{
					if ( !object.hasOwnProperty('pages') )
					{
						object.pages = {};
					}
					
					object.pages[filename] = document;
				}

			}
		}
		// create new key for directory
		else
		{
			if ( !object.hasOwnProperty('pages') )
			{
				object.pages = {};
			}

			// test if object has key
			if ( object.pages.hasOwnProperty( dirs[0] ) )
			{
				var newObject = object.pages[ dirs[0] ];
			}
			else
			{
				var newObject = object.pages[ dirs[0] ] = {};
			}
			
			dirs.shift();

			this.recurseFiles( file, newObject, dirs, ++depth );
		}

	}


	buildServer()
	{

		this.app.use(this.bodyParser.urlencoded({ extended : true }));
		this.app.use(this.bodyParser.json());

		this.app.set('views', this.settings.views);  
		this.app.set('view engine', this.settings.engine);

		this.app.use(this.express.static(`${__dirname}/${this.settings.public}`));

		this.server.listen(this.settings.port);


		// now expose middleware _.ready for requests
		this.setMiddleware();

	}


	setMiddleware()
	{

		if ( this.settings.middleware )
		{

			for ( let m; m < this.settings.middleware.length; m++ )
			{

				this.app.use((req, res, next) => {

					this.settings.middleware[m].call(req, res);

					next();

				});

			}

		}

		// now expose routes _.ready for requests
		this.setRoutes();

	}


	setRoutes()
	{

		this.app.get('*', (req, res) => {

			// try loading the page
			_.read.file(`${this.settings.content}${req.url}.md`, (err, file) => {

				// if it fails, we assume its a section, so look for the _.index page
				( err )

					// try loading the _.index page
					? _.read.file(`${this.settings.content}/${req.url}/${this.settings._.index}.md`, (err, file) => {

						// if it fails, the page doesn't exist at all, 404
						( err )
							
							? this.render(err, req, res, file)
						
							// _.index page does exist, so render template
							: this.render(err, req, res, file);

					})

					// normal page does exist, so render template
					: this.render(err, req, res, file);

			});

		});

		return;

	}


	renderDev()
	{

	}

	renderProd()
	{

	}


	render( err, req, res, file )
	{

		if ( err )
		{
			res.render(this.settings.error, 
			{
				Chief : this.map
			});
		}
		else
		{
			const map 		= this.setLocal(file),
				  template 	= this.setTemplate(req.url, map);

			res.render(template, 
			{
				Chief : map
			});
		}

		return;

	}


	setLocal( file )
	{

		const data = file.split(`${this.settings.divider}`);

		let local = _.read.data(data[1]);

		local.markdown = _.read.content(data[2]);


		return {
			global 	: this.map.global,
			pages 	: this.map.pages,
			local 	: local
		};

	}


	setTemplate( path, map )
	{

		if ( map.local.hasOwnProperty('template') )
		{
			return map.local.template;
		}
		else
		{

			const dirs 		= path.split('/').filter(function(e){return e;}),
				  templates = this.getTemplate(this.map.pages, dirs, []);

			for ( let t = 0; t < templates.length; t++ )
			{
				if ( templates[t] )
				{ 
					return templates[t];
				}
			}

			return 'index';

		}

	}


	getTemplate( data, dirs, templates )
	{

		if ( dirs.length > 0 && dirs[0] !== this.settings.index )
		{

			const dir 		= dirs[0],
				  current 	= data[dir];

			const template = ( current.hasOwnProperty('config') )

								? ( current.config.hasOwnProperty('template') ) 

									? current.config.template 

									: false

								: false;

			dirs.shift();

			templates.unshift(template);

			return this.getTemplate(current.pages, dirs, templates);

		}
		else
		{
			return templates;
		}

	}


	compile()
	{

		// !!! The process !!! //

		// glob content and glob compiled
		// use returned files to create arrays of files and directories
		// reduce arrays down to unique directory paths and files
		// then we trigger our erase and write cycle based on a diff of the arrays

		// 1. write directories
		// 2. write files
		// 3. erase files
		// 4. erase directories


		// !!! lets go !!! //

		// glob content and compile files
		const files 	= _.glob(`${this.settings.content}/**/*.md`),
			  compiled 	= _.glob(`${this.settings.compiled}/**/*.html`),

		// reduce files array down to unique directory paths
			  contentDirs = _.reduceDirectories(files),
			  compileDirs = _.reduceDirectories(compiled),

		// diff the arrays to find new or old directories and files
			  contentDiff = _.diffDirectories(contentDirs, compileDirs),
			  compileDiff = _.diffDirectories(compileDirs, contentDirs),

		// update the paths to resolve to the compiled directory
			  contentPaths = _.updateDirectories(contentDiff, this.settings.compiled),
			  compilePaths = _.updateDirectories(compileDiff, this.settings.compiled);
		

		// !!! begin the erase and write cycle !!! //
		this.writeDirectories(files, compiled);

	}


	writeDirectories( files, compiled )
	{


		if ( contentPaths )
		{
			// use sync _.write as shallow dirs need to be made before deepest dirs
			for ( let dir = 0; dir < contentPaths.length; dir++ )
			{
				_.write.dir(contentPaths[dir]);
			}
		}

		if ( compilePaths )
		{
			// use sync _.write as shallow dirs need to be made before deepest dirs
			for ( let dir = 0; dir < compilePaths.length; dir++ )
			{
				_.erase.dir(compilePaths[dir]);
			}
		}


		this.writeFiles(files);

	}


	writeFiles( files )
	{

		for ( let file = 0; file < files.length; file++ )
		{

			const path = files[file];

			_.read.file(path, (err, file) => {

				let url 		= path.replace(this.settings.content, '').replace('.md', ''),
					compile 	= path.replace(this.settings.content, this.settings.compiled).replace('.md', '.html'),

					map 		= this.setLocal(file),
					template 	= this.setTemplate(url, map),
					extension 	= ( _.index(template, '.jade') ) ? '' : '.jade',
					
					html 		= pug.renderFile(`${this.settings.views}/${template}${extension}`, { Chief : map });


				_.write.file(compile, html, (err) => {

					if ( err )
					{
						console.log('+++ FILE ERROR +++');
						console.log(err);
					}
					else
					{
						console.log('FILE made');
					}

				});

			});

		}

	}


	eraseFiles()
	{



	}


	eraseDirectories()
	{


		
	}


}


module.exports = Chief;


